import os
import json
from typing import Optional, Dict, Any

from dotenv import load_dotenv
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from openai import OpenAI

load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key)

router = APIRouter()


class NearbyRequest(BaseModel):
    lat: float
    lng: float
    max_distance_km: float = 10.0
    category: Optional[str] = None


class CultureChatRequest(BaseModel):
    message: str
    city_code: Optional[str] = None
    lat: Optional[float] = None
    lng: Optional[float] = None


culture_system_prompt = """
You are a backend service for a travel web app. The user sends you a JSON object with geographic coordinates and an optional cultural category. You must respond ONLY with a single valid JSON object with this exact structure:

{
  "region_label": "string, human-readable area name like 'Košice, Slovakia'",
  "city_code": "string or null, short code like 'kosice', 'bratislava', etc.",
  "groups": {
    "0-2": [
      {
        "id": "string, unique id",
        "name": "string, place name",
        "type": "string, short type like 'Cathedral', 'Museum'",
        "description": "string, 1-3 sentences, 40-80 words, in natural English, marketing style",
        "image": "string, HTTPS URL of a representative image",
        "rating": 4.0,
        "address": "string, approximate address or area name",
        "category": "historic" | "museums" | "theaters" | "religious" | "parks",
        "city": "string, city name",
        "city_code": "string, same city code as above",
        "country": "string, country name",
        "distance_km": 1.2
      }
    ],
    "2-5": [],
    "5-10": []
  }
}

Rules:
- You MUST return valid JSON parsable by standard JSON parsers. No comments, no extra text.
- Use the input coordinates to infer a plausible nearby city and country.
- region_label should be '<City>, <Country>'.
- city_code should be a short lowercase identifier without spaces, like 'kosice', 'bratislava', 'prague', 'vienna'.
- Each group key ("0-2", "2-5", "5-10") must be present and map to a list (possibly empty).
- distance_km must be a number within the range of the group:
  - group "0-2": 0 <= distance_km <= 2
  - group "2-5": 2 < distance_km <= 5
  - group "5-10": 5 < distance_km <= 10
- For each group that is non-empty, generate 2–4 places.
- Category field of each place must be one of:
  "historic", "museums", "theaters", "religious", "parks".
- If the user provides a category, prioritize that category, but you may mix in a few other categories.
- description must be attractive for tourists, but do not mention that it was generated by AI.
- image must be an https URL that looks like a real photo URL.
"""


culture_chat_system_prompt = """
You are a cultural and city history assistant for a travel web app chat.

Rules:
- The user will ask about the history, culture, and landmarks of a city.
- You may receive a city_code and/or coordinates as JSON context.
- Answer in natural English, 2–5 sentences.
- Be friendly, accurate, and concise.
- Do not mention that you are an AI model.
- Do not output JSON, only plain text answer.
"""


def ensure_api_key():
    if not api_key:
        raise HTTPException(status_code=500, detail="OPENAI_API_KEY is not configured")


@router.post("/nearby")
async def nearby_culture(req: NearbyRequest):
    ensure_api_key()
    payload = {
        "lat": req.lat,
        "lng": req.lng,
        "max_distance_km": req.max_distance_km,
        "category": req.category,
    }
    try:
        resp = client.chat.completions.create(
            model="gpt-4.1-mini",
            messages=[
                {"role": "system", "content": culture_system_prompt.strip()},
                {"role": "user", "content": json.dumps(payload, ensure_ascii=False)},
            ],
            temperature=0.5,
            response_format={"type": "json_object"},
            timeout=20,
        )
        content = resp.choices[0].message.content
        data: Dict[str, Any] = json.loads(content)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Culture nearby error: {str(e)}")

    if not isinstance(data, dict) or "groups" not in data:
        raise HTTPException(status_code=500, detail="Invalid model response format.")

    if "0-2" not in data["groups"]:
        data["groups"]["0-2"] = []
    if "2-5" not in data["groups"]:
        data["groups"]["2-5"] = []
    if "5-10" not in data["groups"]:
        data["groups"]["5-10"] = []

    return {"status": "success", "data": data}


@router.post("/chat")
async def culture_chat(req: CultureChatRequest):
    ensure_api_key()
    text_payload = {
        "message": req.message,
        "city_code": req.city_code,
        "lat": req.lat,
        "lng": req.lng,
    }
    try:
        resp = client.chat.completions.create(
            model="gpt-4.1-mini",
            messages=[
                {"role": "system", "content": culture_chat_system_prompt.strip()},
                {"role": "user", "content": json.dumps(text_payload, ensure_ascii=False)},
            ],
            temperature=0.6,
            timeout=20,
        )
        reply = resp.choices[0].message.content.strip()
        return {"status": "success", "reply": reply}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Culture chat error: {str(e)}")
